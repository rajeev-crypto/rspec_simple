=begin
- In this chapter, we'll learn the basics of using RSpec. We'll write simple tests for a simple bit of Ruby code. Let's begin by getting our files organized. The first thing we're going to need if we're going to write RSpecs for some code, is the code that we want to write it for. So I've got a very simple project here, called car_project. You can open that up and see that there's just two files in it, init.rb and a directory called lib that has a file, car.rb in it. I'm going to actually open that whole folder up in TextMate so we can take a look at it there. Now, it doesn't matter where this project is located. It can be absolutely anywhere on your computer, as long as we can navigate there from the command line. So let's also do that. Let's go into our command line. You can see that I'm in my user directory right now, and I'm just going to navigate into my desktop and into that car_project. So that's where I am now. Now, I'm inside that car_project directory. And now when I issue commands to RSpec, it will be using that directory. That's where it'll be working from. All right, let's go back and actually take a look at the project. Init.rb is very simple. It requires that car.rb file that's in the lib directory. Then it outputs some text at the beginning: "Enter information for the car you want to purchase." It gets the make, the year, and the color from the user. And then, it creates a new car object using all of that, and then just simply outputs the text: "I understand that you want to purchase," car.full_name. So it calls this full_name method. If we take a look at the car class, you'll see it's a very simple class called car. It has attribute accessor for make, year, and color. It also has an attribute reader for wheels and an attribute writer for doors. And then, when we initialize it, which we did with new, then we can pass in the make, the year, and the color. And then, by default, it gets the number of wheels set for it. We have the method, full_name that we saw here. We also have a class method, called colors, that's there. So it's a very simple Ruby program, that, hopefully, will be very easy for you to understand. Let's just try running it real quick. So from inside that directory, if I just call Ruby init.rb, then hit return. Enter information for the car you want to purchase. I'm going to say, I want to purchase a Honda from 2011, color blue. I understand that you want to purchase a 2011 Honda, and then in parenthesis, blue. That's it. That's all it does. Very simple program. All right, so now we want to write test for this program. The first thing that we want to do is initialize the project for use with RSpec. And that's very easily done by just typing rspec, space, --, and then init. We'll hit return and it creates two files for us. A .rspec file, that's that configuration file for the project. And then it creates the spec_helper.rb inside a directory called spec. If we take a look back in our project, you can see that it created that for us. And the spec helper has some information in it that's all commented out, but it has some RSpec configuration. We want to go ahead and have that in there, right? So this gives us all the basics of working with RSpec. A lot of it's commented out. We'll talk a bit more about it later. So we have a spec helper, but we don't actually have a spec yet. We want to create a new spec and we want to put it in this spec directory. With TextMe, I can do that by hitting the button down here to create a new file. You can also do it from your operating system as well. And I'm going to call that file car_spec.rb. I'll create that file. Now notice, this car_spec.rb has a direct relationship to the code in our lib directory, car.rb. That's not a coincidence. There's a one to one mapping between the specs and the things that they test. So car_spec.rb is presumably the spec for car.rb. You'll want to keep with this convention to keep your files organized. Now, the very first thing you want to add to that car_spec.rb is that it needs to require "car," right? If we're going to run this spec, then it has to have access to that car class. That car class is necessary for us to start testing it. Once we have that we can save the file and we have our basic starting point. We have our test project, it's been initialized to work with RSpec, and we have our first spec file that's ready for us to fill out with our examples. In the next movie, we'll learn the basic syntax for how to write those examples. 
=end 

=begin
 In this movie, we'll learn the Basic Syntax of using RSpec. In RSpec, describe is used to define an example group. Describe takes one argument, which can either be a string or a class name. In this case, since we're describing the 'Car' class, we could really use either one. We'll talk more about what benefits you gain when you use a class name later on. For now, let's just use a simple string. The main purpose of this string is for use during the test output. So that you'll know which tests RSpec is referring to. Describe also has a Ruby block that comes after that's everything from do down to end. Everything inside is part of this example group. What goes inside an example group? Examples, of course. It is used to define an example. Specify is also a word you can use as an alias for it, but I think you'll find that most people use it. The it which is being referred to here is 'Car'. It also accepts a string and has a Ruby block. Again, the string is used mostly for output. Notice how easily it reads. It "allows reading for :wheels". It's a nice, simple sentence that we can read and make sense of. This is intentional and it's a best practice that you should follow. You can further group your examples by having more describes This is really a matter of personal preference and how you want to keep your code organized. Personally, I like to have a new example group for each method in a class that I'm writing a test for. So in this case, I'm writing a set of tests for the method '.colors'. That's a class method. And, so I'm going to say describe '.colors' it "returns an array of color names". Notice that it doesn't refer to 'Car' anymore, I'm referring to '.colors'. That can help you understand when you need to use another describe. So in this case, the method '.colors' "returns an array of color names". You can also use context instead of describe because context is just an alias for describe. Context usually makes more sense when we're not just grouping, but we're in fact setting up a context for our test. For example, we might have a context for when a user's billing is past due and then we would add code that would set up a user with a billing that's past due and all the tests inside that context would be related to that user who's billing is past due. For the moment, I'm going to stick with describe. Now inside our example, we'll have expectations. We'll talk a lot more about the Syntax of expectations in the next chapter. For now, I want you to notice a few things. There are four main parts, expect, then an argument to expect, then a mat we call the method .to, see that .to. and then an argument to the method .to. Don't let the fact that Ruby let's you omit the parenthesis around match_array(c) fool you. All of that is in fact an argument to the .to method. Match_array is called a matcher and we'll talk more about those later. For now, make sure that you see that fundamental Syntax that an expectation takes, because all expectations have this form, expect something .to something or expect something .not_to something. This is the fundamental way that we test things in RSpec. So again, let's make sure we understand that Hierarchy. At the top level we have our spec file, car_spec.rb. Inside there, we have our example groups and those use the method describe. We can have additional groups inside there. We call those nested groups and they can use describe / context, and it's really up to us how we use those. And then inside there, we have our examples. Those use the method it and inside each example are the expectations expect something .to something. It's not a bad idea for you to pause the movie here and just make sure that you have this Hierarchy really set in your head. Because it is the fundamental structure that all of our spec files are going to take. Now that we understand the basic Syntax and how this Hierarchy works. In the next movie, let's actually install some tests into our car_spec test file. 
=end 

=begin

  Now that we understand the basic syntax of our spec, we're ready to put it into practice, and actually write the specs that are going to go into our Car Spec file. I've gone ahead and pasted in some code, that we can look at to understand how these work. So we don't actually have to write it in real time. We've still got our require car line at top, that's going to make sure that we have the Car class available to us for our tests. It's going to be very important if we're going to test the class, we need to actually have it there. Then we've got our first example group, describe. And everything from do, down to end, is part of that example group. Then I've got three more nested example groups inside there, again, this is a matter of personal preference. I've got one for the attributes, you can go back and look at our file, you see I've got all these attribute accessors, and readers and writers. So I've got those there. That's what I'm going to be testing with that. I've got another one for colors, and I've got another one for #full_name. Those are two methods in the Car class. If you notice, if we go back and look at Car again, colors is a class method. So I just need to have the class Car, and then I can call colors on it. But full_name is an instance method, so I need an actual instance of it, before I can call that. There's a convention in Ruby, and especially in our spec, that for class methods, we put a dot in front of the name, and for instance methods, we put a pound or hash sign in front of that name. So that's how we're table to tell the difference between a class method and an instance method. Now, TextMate lets me fold all those up, which is nice, I can unfold these, and take a look at them. Inside describe attributes, I've got my first example. So this is a nested example group, this is an example. It allows reading and writing for :make. Now this can be any string you want, but it needs to explain what this example is doing. And then inside there, inside this block from do end, I've got my expectations. And here's my expectation down here. Now in order to get to that expectation, I need to write a little bit of Ruby code, and this is very common. We need to do a bit of setup. Car is going to be equal to a new instance of the Car class, I should be able to write to it and read to it. So what's a good way to test that? Well, let's try setting a value to make, and then reading that value back, right here. So if I set make equal to Test, and then I read that value back, then I would expect car.make to equal Test. Don't worry too much about this matcher, we'll talk more about matchers later. For now, it's just testing equality. So, is car.make going to be equal to Test? If true, then my expectation will pass, my test will pass. If it's false, then I'll get a failure, and I've got the same thing for reading and writing to year, and reading and writing to color, so we won't spend a lot of time on those. But let's scroll down here, we've got reading for :wheels. Now, :wheels is something, if you go back and look, I have an attribute reader for it, but I don't have an attribute writer. I can't write to it, it's being set by default in initialize. So I should just be able to read it, and if I take a new Car instance, and I ask for its wheels, I should get back that value of four. Alright, so that's the attributes, let's take a look at colors. It returns an array of color names, and we have our array, blue, black red, and green, and I would expect that when I call Car.colors, again that's a class method, that it will match the array, that I've provided here in c. I've just assigned it to a simple variable, c. If we go back and look, you'll see that blue, black, red, and green, is in fact what it's going to return to me. So that should pass. My expectation should be true. And then I've got #full_name. Now in #full_name, I've actually got two. I've got one here that says describe #full_name, it, meaning the method #full_name, returns a string in the expected format. All right, so let's create a new car. I'm going to call it a Honda, and I'm going to give it a make, a year, and a color, and then I'm going to see, if I call @honda.full_name, do I get back a string in the expected format? So I ought to expect that to equal 2004 Honda, and then in parenthesis, blue, because that's what #full_name ought to do. Now I've got another one down here, I've put context as well. I've said, "when initialized with no arguments" in that context, then it should return a string using default values. See how that works? See how I used contex? So in this special context, when I initialized it with no arguments, then this is the case. Now if this was a more complex method, there might be other things in this same context. I might say it does something else, right, when initialized with no arguments, it does something else. So, the main thing I wanted to hear is for you to get the idea of how a context works. So in that case, when I call Car.new, and I ask for its full_name, then I'm going to get back the default values, 2007 Volvo and unknown. And we can go back here and see those, Volvo, 2007, and unknown, those are the default values. So now we have some examples and expectations of our Car class. We didn't cover everything, we have some methods that cover these attribute accesors here, the attribute reader for :wheels, we don't have one for :doors yet, we don't have one for initialize, we're not testing that. We have one for colors, and we have full_name. So we don't have full spec coverage yet, but we do have a starting point, and this will at least give us a basic set of tests that we can use to actually start running our tests, and see how that process works. That's what we'll do in the next movie.

=end 

=begin 

Now, we're ready to learn how to actually run those examples using our spec. So, I've already navigated into that project directory. Remember it's very important that we start there. And then from there, we can run the rspec command from the command line, and tell it where the spec is that we want to run. So, it's inside the spec directory and it's called car_spec.rb. So, this will run all of the examples that are in that file. So let's hit return and you'll see the output. Now, let's take a look at the output that it gives us. It gives us a . as output for each one of the examples that it runs successfully. And you can see those are green. That's because we've told color to be on in our configuration, and because it was a pass. Because it passed, it turns it green. It also tells us how long it took to run our test. That's good to know. And it tells us how many total examples, and then, most importantly, 0 failures. Now, what does a failure look like? Well, let's create a failure for ourselves. Let's go to this first test here and instead of saying that it ought to be equal to Test, let's just take the last t off, so it's definitely not going to be equal now. That should give us a failure. Let's go back over after we save that file. Let's hit the up arrow and we'll run our test again. And now, we can see what a failure looks like. Our first test has an F at the front because it failed. And then at the end, after it gave us all this status output, it gave us more information about the Failures that it encountered. There was one Failure. Notice the text that it gives us here describing it. Car attributes allows reading and writing for :make. That's the test. Alright, it did not pass. It tells us what the code was for expectation. It said that it expected to get this value, but instead it got this value. That can be very helpful in debugging. It tells us what we thought we should have and it tells us what it got instead. And then, it also tells us where that's located. Once you get a lot of specs, this is super useful because it tells us that we need to go to our car_spec file to line 10. If you scroll over here, line 10, you'll see is where that occurs. And that can help us go directly to the source of the problem in our file. Now, back in the configuration movie, I told you that we can also provide options from the command line. We had set up a default option of having color for our specification, which is why we're seeing reds and greens there. If we instead put --no-color, you'll see what that would give us. Alright, it just gives us basic output. There's no color there at all. Incidentally, if you want to have c and you don't have it set as a default, you could also just use -c and that would do the same thing as having --color. Alright so, we have it in our defaults, so we don't need to specify it. But, there were some others that we can take a look at that are useful. One of them is format, Format progress is the default. That's what we're seeing there where we're seeing those dots. That's the progress. So every time a test gets run, a new dot appears. If we had tests that took a long time, you would really see those dots appear as each test was running. So, you'd see ... and then it would pause for a second while it was running a test, and then another ., and then another pause, and then ..., depending on how fast and slow the tests are. But, we have another option. Besides that, we can have documentation. So, format documentation, let's hit return, run that and see what that looks like. Now, we didn't get the dots. Instead, we get this nice text ouput, Car attributes, and then it gives us a list of all the things that the attributes ought to be able to do. Car .colors, returns an array of color names. #full_name returns a string in the expected format when intialized with no arguments, returns a string using default values. This is very readable and it gives us good documentation for what our class ought to do. Now, there's also a shorter way instead of writing out --format documentation, you can also just put -f space and then d, either d or p, those are short. So just -f space and then d or p will give you documentation load or progress. We also had talked about earlier that you can specify the order. We have the order being defined, but we could also say order random and that would run our tests in a random order. You'll see that our Failure is not the first test that it runs anymore. Now, the Failure came at the end. It also tells you what random seed it used in order to generate this random order and you can actually specify that in the options as well, if you want to run them in this same order again. Let's just try it again with a different random order. And you'll see this time it was the last one and our seed value changed. There was also an option for profiling. You'll remember --profile, the default is no profile. Profiling tells you information about the test. And here after it runs all our tests, just like normal, it then says, "Here's your top 7 slowest examples." Now, we only have 7. If we had 20, it would show us the top 10. You can also configure that to show you a different number, but by default it's set to 10. So here it's showing us which ones are our slowest test. All of the tests are super fast at the moment. But if we did have some longer running tests, maybe a test that goes out to the database to retrieve values, right, it would show us which ones of those were the slowest, so we could work on improving the speed. There's also a shortcut for that which is just simply -p and that will do the same thing. And then, we also had the fail-fast option, fail-fast by default it's no fail-fast. But let's tell it fail-fast and let's see what happens. There it is. It ran one test. It got a failure, and so it stopped. That's it. It didn't keep going. It didn't show us all the problems. As soon as it found a failure, it stopped and said, "Hey, you got a problem. "You might want to fix this." So, it's really up to you whether you like that approach of stopping as soon as you hit a failure, or whether you want it to keep running through what might be hundreds of examples looking for all of the failures, so that you can go through and fix all of them at once. It can also be useful to just run a single test. Maybe now that we have a failure on that test, we just want to run this one test, one time to see if we fixed it. Instead of using the fail-fast option, we can also tell our spec, "Just run the test "that's at line 7", : line 7. See how that works. And that will tell it just to run this test right here. So, let's run it. It fails. We come over here. Let's fix our Test. Let's put the t back in there and save the file. Let's come back. Let's run our test again at line 7. It only ran 1 test for us and it told us that it was a success. That can be very useful when you're trying to just very quickly fix a problem. Just identify the single line number that you want to run. The one last thing that I want to show you about running tests is that it can also be sometimes useful to put in puts values here. Puts "This is output." Alright, I'm just going to put that in there. And because this outputs to standard out, it's going to output during our test. Let's run all of our tests. That can be really useful sometimes when you're debugging. If you're not sure why your test is failing, you can just have those puts output some quick information to the console, so you can actually see what values are before they actually get to the expectation portion of your code. Now that we know how to write examples and we know how to run those examples using RSpec, in the next movie I want to talk about how we can skip over some examples.

=end 


=begin 

Skipping examples and working with pending examples
Selecting transcript lines in this section will navigate to timestamp in the video
- In RSpec, it's also possible to skip over certain examples. We can do that by marking them as being pending, or by telling it that it ought to skip them. Let's see how we do that in this movie. There are two ways that we can mark something as being Pending. We can either simply Omit the block that comes after the description, for the example, or we can use they keyword pending inside the block. For Skipping, we can simply prefix either describe or it, with an x. Just putting an x in front of there will allow us to temporarily skip something. Or, we can use the keyword skip inside the block. Let's see how all of these work. If you recall, when we wrote our specs for the Car class, we did not yet provide an example for this attribute writer, :doors. We did it for :make, :year, :color, and :wheels, but not for :doors. So what I want to do now, is add a pending example for :doors to our spec file. I'm going to fold all of these up under attributes, and down here at the bottom, I'm going to add a new one, it "allows writing for :doors" Now, normally, right after that, we would have do and end, but we're not going to here. Instead, we're going to leave it just like that, so it is just it followed by a string, a description. And RSpec is going to see that as being a pending example. This can be a really useful technique, When you're first coming to your specs, you can map out all the things that your specs ought to do, by using these pending examples, and then come back and get your hands dirty, by actually writing the examples themselves, by providing the block to each one. So for now, we have this pending example it "allows writing for :doors", and if we go back to our car_project directory, and we run rspec on our car_spec file, then you'll see that it comes up and it tells us that we have a pending example, because it's an asterisk instead of a dot, to let us know that it's pending, and it gives us the description, Car attributes allows writing for :doors. Tells us that it's Not yet implemented, and it tells us where it's located, if we want to go and implement it now. We also don't get an all green status line down here. We didn't get any failures, but we did get one pending, and it's letting us know that fact. Every time we run our test, we're going to get this reminder, that we have some specs that are still not complete. Now, it's also possible to skip an example. You can simply skip an example like this first one here, "it allows reading and writing for :make", all we have to do is put an x in front of it. It's a really easy way to do it while we're debugging, we just want to skip over something, just put an x in front of it, save the file, and let's go back and run our specs again. Now, we get two asteriks'. One for each one, it tells us, that these are both pending. Now, it says this one is temporarily skipped with xit, so it tells us that that's why. We can also skip entire groups that way, by putting x in front of describe. I'll save the file, clear the screen, so we can see it better, and now, you'll see that all of those get skipped, and it tells us it's temporarily skipped with xdescribe, so we can quickly omit a whole section if we want, while we're running our tests. Now as I noted in the beginning, there's another way that we can mark things as skipped or pending, and that's to provide the keyword in here, skip. So we'll simply type skip, and save the file, and then let's go back over, and let's run RSpecs again, and this time it says that it skipped, it tells us no reason given. That's because skip will actually take an argument, and we can tell it what's going on here, why are we skipping? Debugging a problem, let's save it, let's go and run RSpecs again, and now you'll see that it actually gives us that message. That can be very useful to remind you why you've marked something as being skipped. You also have the option to use pending in the same way. Either by itself, or with a string following it. Let's save it though, because there's actually a big "gotcha" here that you gotta be careful about. Let's come back over, clear our screen, and let's run it again. Now, this time, instead of getting an asterisk, we got a big, red F. We had a failure. If you look at the Failure, it tells us it was expecting that this pending test would fail. That's the thing about using pending. When you use pending, it still runs this code. And it's expecting that this code is going to fail, that there's a problem with it, that's why you marked it pending, otherwise you would have used skip. Pending means there's a problem here, I need to resolve later, and this code still runs. That can be very important, especially if this is a problem test that's making calls to the database and taking a long time, that code is still running. When we call skip, these lines do not run, they get skipped, as soon as it gets to skip, it just moves on to the next thing. With pending, it does still run those tests, and it does expect them to fail. Now watch this, let's actually make it a failing test, right, car.make should not be equal to Tes, right, it should be equal to Test. Let's come back and let's run it again. And now we get what we expected, now it says "Yes, it is pending." It ran the test, it went ahead and executed this code, and it failed, which is what it was expecting. Now why does it do that? Well, it's so that it lets you know if somehow your test got fixed, it raises it as an issue so that you know that this can be fixed, we can take away the pending, because now we have a passing test. Something that we've done has fixed it in the process. So be careful about that, that's a different behavior than we had in RSpec 2, this is a new way of doing things in RSpec 3. So just to recap, if you want something to be Pending, you can Omit the block, or you can Use pending inside the block, but be careful, because it must be a failing test, and that code will still be executed. Or, you can Skip it, and if you Skip it, you can do it by simply putting an x in front of an example group, or in front of the example, or using the word skip inside the block.

=end 

require 'car'

describe 'Car' do
  describe 'attributes'  do

    it "allows reading and writing for :make " do 
    	car = Car.new 
    	car.make = 'Test'
    	expect(car.make).to eq('Test')

    end 

    it "allows reading an writing for :year" do 
    	car = Car.new 
    	car.year = 9999
    	expect(car.year).to eq(9999)
    end 

    it "allows reading and writing for :color" do
       car = Car.new 
       car.color  = 'foo'
       expect(car.color).to eq('foo')

    end 

    it "allows reading for :wheels" do
       car = Car.new 
       expect(car.wheels).to eq(4) 
    end 

    describe '.colors' do
      it "returns an array of color names" do 
      	c = ['blue', 'black', 'red', 'green']
      	expect(Car.colors).to match_array(c)
      end  
    end 

    describe '#full_name' do 
    	it "returns a string in the expected format" do
    	  @honda = Car.new(:make=> "Honda", :year => 2005,:color => 'blue')
    	  expect(@honda.full_name).to eq('2005 Honda (blue)') 
    	end 

    	context 'when initialized with no arguments' do 
    		it 'returns a string using defaults values' do
    		   car = Car.new
    		   expect(car.full_name).to eq('2007 Volvo (unknown)') 
    		end 
    	end 
    end 
  

  end 
end 